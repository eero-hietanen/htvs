import ringtail as rtc
from joblib import Parallel, delayed
from rdkit import Chem
from meeko import MoleculePreparation, PDBQTWriterLegacy
from vina import Vina
from openbabel import openbabel, pybel
import os
from re import split, sub, MULTILINE
from scrubber import Scrub

# START: Script params.

batch_size = 1000  # Number of ligands per batch. Processing is done in batches as the ligand strings are held in memory during processing.
n_cores_meeko = -1  # Core count for Meeko multiprocessing using joblib.
n_cores_vina = 18 # Core count for Vina multiprocessing.
n_cores_scrubber = 18 # Core count for Scrubber.
vina_scoring_function = "vina" # Scoring function to use with Vina.

# Data input directory holding ligand library and receptor.
input_directory = "Data/"
if not os.path.exists(input_directory):
    os.makedirs(input_directory)

# Output directory for the Ringtail database.
output_directory = "Output/"
if not os.path.exists(output_directory):
    os.makedirs(output_directory)

# Ligand library file in .sdf format.
sdf_file = input_directory + "ligands_10.sdf"

# Ligand library file in .smi format.
smi_file = input_directory + "ligands_2000.cxsmiles"
smi_file_no_header = input_directory + "ligands_10_2.smi"

# Receptor file in .pdbqt format.
# The receptor should be previously prepared with Meeko 'mk_prepare_receptor.py' (doesn't seem to be a Python API available, but could be done by calling it as a subprocess).
receptor_file = input_directory + "9F6A_prepared.pdbqt"
save_receptor_to_db = True

# Docking box params for Vina.
docking_box = {"center": [136.733, 172.819, 99.189], "box_size": [11.69, 7.09, 7.60]}

# Initialize a Vina instance.
vina_instance = Vina(sf_name = vina_scoring_function, cpu = n_cores_vina)

# Initialize the Ringtail database.
db = rtc.RingtailCore(db_file = output_directory + "output.db", docking_mode = "vina")

# END: Script params.

##############################################

# Helper function for format conversion. Not needed if staying within rdkit mol objects.
def smiles_to_obmol(smiles_string):
    # Create an OpenBabel conversion object
    obConversion = openbabel.OBConversion()
    obConversion.SetInAndOutFormats("smi", "mol")
    
    # Create an OBMol object
    obmol = openbabel.OBMol()
    
    # Convert SMILES to OBMol
    obConversion.ReadString(obmol, smiles_string)
    
    return obmol

# Function to convert a ligand to .pdbqt format using Meeko on the fly.
# Uses rdkit to add explicit hydrogens and 3D coordinates for the ligand.
def molecule_prep(smiles, mol_name):

    # Set up Scrubber parameters. Variants are genereated for each ligand. The variant names are appended with an index number and all of them are directed to Vina for docking.
    """
    Permitted parameters:
    ph_low=7.4,
        ph_high=None,
        pka_fname=None,
        tauto_fname=None,
        skip_acidbase=False,
        skip_tautomers=False,
        skip_ringfix=False,
        skip_gen3d=False,
        template=None,
        template_smarts=None,
        do_gen2d=False,
        max_ff_iter=200,
        numconfs=1, # Number of conformers generated by default is 1. Changing this doesn't seem to have any effect on the number of ligands forward to Vina?
        etkdg_rng_seed=None,
        ff="mmff94s",
    """
    scrub = Scrub(
        ph_low = 6.9,
        ph_high = 7.9,
    )

    try:
        # Reconstruct the RDKit molecule from the SMILES string.
        mol = Chem.MolFromSmiles(smiles)
        if mol is None:
            print(f"Warning: Invalid SMILES string for {mol_name}: {smiles}")
            return []

        # Assign the molecule name to the RDKit object.
        mol.SetProp('_Name', mol_name)

        # Prepare the ligand with Meeko.
        preparator = MoleculePreparation()

        variants = []

        # Wrap the scrub(mol) in a try-except block
        try:
            # Scrubber handles protonation states, 3D coordinates, and tautomers.
            for mol_index, mol_state in enumerate(scrub(mol)):
                variant_mol_name = f"{mol_name}-{mol_index}"
                
                fragments = Chem.GetMolFrags(mol_state, asMols=True)
                if len(fragments) > 1:
                    mol_state = max(fragments, key=lambda m: m.GetNumAtoms())

                mol_setups = preparator.prepare(mol_state)

                for setup in mol_setups:
                    pdbqt_string, is_ok, error_msg = PDBQTWriterLegacy.write_string(setup)
                    if is_ok:
                        modified_pdbqt = f"REMARK Name = {variant_mol_name.strip()}\n{pdbqt_string}"
                        variants.append((variant_mol_name, modified_pdbqt))
        except RuntimeError as e:
            print(f"Warning: Failed to process {mol_name} with Scrubber: {str(e)}")
            # Continue to the next molecule by returning an empty list
            return []

        return variants

    except Exception as e:
        print(f"Error processing molecule '{mol_name}': {str(e)}")
        return []
    
# Alternate molecule preparation function using Open Babel to account for protonation states.
# Input is fixed to be the ligand library in .smi format.
# Input molecules are in pybel molecule format.
def molecule_prep2(idx, mol):
    try:

        # Fetch the SMILES string and molecule name.
        # smiles_string = split("\t", mol.write(format = "smi"))[0]
        # mol_name = split("\t", mol.write(format = "smi"))[1]
        smiles_string = split("\t", mol)[0] # The mol object here is just a string as we do conversion during the batching.
        mol_name = split("\t", mol)[1]

        # Convert the pybel molecule to Open Babel molecule.
        # obmol = mol.OBMol
        obmol = smiles_to_obmol(mol)

        # Add hydrogens and consider protonation states.
        obmol.AddHydrogens(False, True, 7.4)

        # Convert the Open Babel molecule back to pybel molecule.
        mol = pybel.Molecule(obmol)

        mol.make3D()

        output_string = mol.write(format = "pdbqt")
        # modified_pdbqt = f"REMARK  Name = {mol_name.strip()}\nREMARK  SMILES = {smiles_string.strip()}\n{pybel_string}"
        # modified_pdbqt = f"REMARK SMILES {smiles_string.strip()}\n{output_string}"
        # modified_pdbqt = sub(r'^REMARK\s+Name\s*=.*$', f'REMARK Name = {mol_name.strip()}', modified_pdbqt, flags=MULTILINE) # Replaces the Name remark with the molecule name.
        
        modified_pdbqt = sub(r'^REMARK\s+Name\s*=.*\n', '', output_string, flags=MULTILINE)
        modified_pdbqt = f"REMARK Name = {mol_name.strip()}\nREMARK SMILES {smiles_string.strip()}\n{modified_pdbqt}"
        


        print(modified_pdbqt)

        return idx, modified_pdbqt
    except Exception as e:
        return idx, None, str(e)
    
# Testing of modified molecule_prep2 function to include protonation states.
def molecule_prep3(smiles, mol_name):
    try:      
        
        smiles_string = smiles.strip().split("\t")[0]

        # Convert the pybel molecule to Open Babel molecule.
        # obmol = mol.OBMol
        obmol = smiles_to_obmol(smiles)

        # Add hydrogens and consider protonation states.
        obmol.AddHydrogens(False, True, 7.4)

        # Convert the Open Babel molecule back to pybel molecule.
        mol = pybel.Molecule(obmol)

        mol.make3D()

        output_string = mol.write(format = "pdbqt")
        
        modified_pdbqt = sub(r'^REMARK\s+Name\s*=.*\n', '', output_string, flags=MULTILINE)
        modified_pdbqt = f"REMARK Name = {mol_name.strip()}\nREMARK SMILES {smiles_string.strip()}\n{modified_pdbqt}"
        
        return mol_name, modified_pdbqt
    except Exception as e:
        return mol_name, None, str(e)

# Docking function using Vina.
# Uses Vina's own multiprocessing.
def dock_ligands_with_vina(vina_instance, receptor_file, docking_box, ligands):
    vina_instance.set_receptor(receptor_file)
    vina_instance.compute_vina_maps(**docking_box)

    # Initialize an empty dictionary to store the results. This will be the input for Ringtail.
    vina_output = {}

    # Store results as strings.
    for idx, pdbqt_string in ligands:
        try:
            vina_instance.set_ligand_from_string(pdbqt_string)
            vina_instance.dock(exhaustiveness = 32, n_poses = 5) # NOTE: Ringtail saves the top 3 poses per ligand by default. NOTE: Drop exhaustiveness especially if joblib paralallization works.
            vina_poses = vina_instance.poses()

            # Build a results dictionary from the Vina docking results that can be used as an input for Ringtail database.
            # The result dictionary key should be the pdbqt_string of the liganda, and the value should be the vina_poses.
            vina_output[idx] = vina_poses # The dictionary key should be the molecule name instead of the whole string.

            # vina_instance.write_poses('docked.pdbqt', n_poses=5, overwrite=True) # Testing of docking output.
            # print(vina_poses) # Testing docking output for correct file format. Checked with SMILEs input: OK.
         
        except Exception as e:
            print(f"Error docking ligand {idx}: {e}")

    return vina_output

# Function to handle batching of ligands.
def process_batches(ligand_input_file, batch_size):

    # Initialize the moleculer supplier. NOTE: None of these suppliers are needed if we batch using the input .smi file and direct the batches to joblib.
    # suppl = Chem.SDMolSupplier(ligand_input_file) # SDMolSupplier is an iterator. There's also an experimental 'MultithreadedSDMolSupplier' that may be faster.
    # suppl2 = Chem.SmilesMolSupplier(smi_file, delimiter="\t") # Iterator for the .smi ligand file.
    # suppl2 = Chem.SmilesMolSupplierFromText(smi_file, delimiter="\t") # This iterator might work better than the above one.
    # NOTE: Suspicion is that the pybel.readfile() iterator causes the pickling issue with joblib.
    # suppl4 = pybel.readfile("smi", smi_file_no_header) # Test pybel iterator for the ligand batching.

    batch = []
    file_extension = os.path.splitext(ligand_input_file)[1].lower()

    # Read the SMILES file and extract SMILES strings and names.
    # TODO: Check if adding the remaining cxsmiles fields should be done here.
    with open(ligand_input_file, "r") as f:

        if file_extension == '.cxsmiles': # Ignore the first row of a .cxsmiles file as it's a header row.
            next(f)

        for line in f:
            parts = line.strip().split("\t")
            if len(parts) >= 2:  # Ensure the line has both SMILES and name.
                smiles, mol_name = line, parts[1]
                batch.append((smiles, mol_name))  # Append a tuple of SMILES and name.

            # When the batch reaches the specified size, process it.
            if len(batch) == batch_size:
                converted_batch = Parallel(n_jobs=n_cores_meeko)(
                    delayed(molecule_prep)(smiles, mol_name) for smiles, mol_name in batch
                )

                # The converted_batch list is flattened as it is a list of lists, which is a result of generating the variants for each ligand.
                flattened_batch = [variant for molecule_variants in converted_batch for variant in molecule_variants]

                # Dock the converted batch of ligands using Vina.
                # TODO: See if this can be parallelized using joblib.
                vina_results = dock_ligands_with_vina(vina_instance, receptor_file, docking_box, flattened_batch)
                db.add_results_from_vina_string(vina_results, finalize = False) # Add docking results to the Ringtail database.
                batch.clear() # Clear the batch in preparation for the next batch.
                converted_batch.clear() # Clear the converted batch in preparation for the next batch.

    # Process the leftover ligands in the last batch.
    if batch:
        converted_batch = Parallel(n_jobs=n_cores_meeko)(
            delayed(molecule_prep)(smiles, mol_name) for smiles, mol_name in batch
        )
        
        flattened_batch = [variant for molecule_variants in converted_batch for variant in molecule_variants]

        vina_results = dock_ligands_with_vina(vina_instance, receptor_file, docking_box, flattened_batch)
        db.add_results_from_vina_string(vina_results, finalize = False) # Add the "add_interactions" param. here?
        batch.clear()
    
    # Save the receptor to the Ringtail database.
    if save_receptor_to_db:
        db.save_receptor(receptor_file = receptor_file) # This will cause an issue if the receptor is already saved to the db from a previous script execution.
    print("\nReceptor successfully saved to the database.")
    
    db.finalize_write()

# Process all batches and add docking results to Ringtail database.
process_batches(smi_file, batch_size)

# Make a filter for the top 5% of docking results.
db.filter(score_percentile = 5, bookmark_name = "top_5p_results")
# db.write_molecule_sdfs(bookmark_name = "bm1")
print("\nDocking results successfully added to the Ringtail database.")

#NOTE: The Ringtail command line option to write sdf files is rt_process_vs read --input_db output.db --bookmark_name bookmark1 --export_sdf_path sdf_files/
#TODO: Implement a receptor preparation method. See about also exporting the specified box .pdb file.
